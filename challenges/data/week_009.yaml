# Week 9: Object-Oriented Programming Basics

title: "Classes and Objects"
description: "Introduction to Object-Oriented Programming - creating classes, objects, and understanding encapsulation."
topics:
  - Classes and objects
  - __init__ method
  - Instance variables
  - Methods
  - self parameter
  - Creating multiple objects

challenges:
  - day: 1
    title: "Create a Simple Class"
    topic: "Class Basics"
    keywords: ["functions"]
    difficulty: intermediate
    time_estimate: "50-65 minutes"
    description: |
      Learn to create your first class!
      
      ## ðŸŽ“ LESSON: Introduction to Classes
      
      ### Part 1: What is a Class?
      
      A class is a **blueprint** for creating objects. Think of it like a cookie cutter - one cutter, many cookies!
      
      **Real-world analogy:**
      - Blueprint (class) â†’ House (object)
      - Recipe (class) â†’ Cake (object)
      - Person class â†’ Alice object, Bob object
      
      ### Part 2: Creating a Class
      
      Use the `class` keyword:
      
      ```python
      class Person:
          pass  # Empty for now
      ```
      
      ### Part 3: The __init__ Method
      
      `__init__` runs when creating a new object:
      
      ```python
      class Person:
          def __init__(self, name, age):
              self.name = name
              self.age = age
      ```
      
      **What `self` means:**
      - `self` represents the specific object
      - `self.name` = this object's name
      - `self.age` = this object's age
      
      ### Part 4: Creating Objects
      
      ```python
      # Create two Person objects
      alice = Person("Alice", 25)
      bob = Person("Bob", 30)
      
      print(alice.name)  # "Alice"
      print(bob.name)    # "Bob"
      
      # Different objects, different data!
      ```
      
      ### Part 5: Adding Methods
      
      Methods are functions inside a class:
      
      ```python
      class Person:
          def __init__(self, name, age):
              self.name = name
              self.age = age
          
          def greet(self):
              return f"Hello, I'm {self.name}!"
          
          def have_birthday(self):
              self.age += 1
      
      alice = Person("Alice", 25)
      print(alice.greet())  # "Hello, I'm Alice!"
      alice.have_birthday()
      print(alice.age)      # 26
      ```
      
      ### Part 6: Complete Example
      
      ```python
      class Dog:
          def __init__(self, name, breed):
              self.name = name
              self.breed = breed
          
          def bark(self):
              return f"{self.name} says Woof!"
      
      # Create two dogs
      dog1 = Dog("Buddy", "Golden Retriever")
      dog2 = Dog("Max", "Poodle")
      
      print(dog1.bark())  # "Buddy says Woof!"
      print(dog2.bark())  # "Max says Woof!"
      ```
    
    instructions: |
      Create a Person class.
      
      Your class should:
      - Have an __init__ method that takes name and age
      - Store these as instance variables
      - Have a method greet() that returns "Hello, I'm {name}"
    
    starter_code: |
      class Person:
          def __init__(self, name, age):
              # Your code here
              pass
          
          def greet(self):
              # Your code here
              pass
    
    hints:
      - "Store parameters as instance variables: self.name = name"
      - "self refers to the current object"
      - "Access instance variables in methods: self.name"
      - "Example: return f'Hello, I\\'m {self.name}'"
    
    tests:
      - class: Person
        init: ["Alice", 25]
        method: greet
        expected: "Hello, I'm Alice"

  - day: 2
    title: "Bank Account Class"
    topic: "Methods and State"
    keywords: ["functions", "math"]
    difficulty: intermediate
    time_estimate: "55-70 minutes"
    description: |
      Model a bank account with methods!
      
      ## ðŸŽ“ LESSON: State Management in Classes
      
      ### Part 1: Objects Have State
      
      State = data that changes over time:
      
      ```python
      class BankAccount:
          def __init__(self):
              self.balance = 0  # Initial state
          
          def deposit(self, amount):
              self.balance += amount  # State changes!
          
          def get_balance(self):
              return self.balance
      
      account = BankAccount()
      print(account.get_balance())  # 0
      account.deposit(100)
      print(account.get_balance())  # 100
      ```
      
      ### Part 2: Methods Modify State
      
      ```python
      class Counter:
          def __init__(self):
              self.count = 0
          
          def increment(self):
              self.count += 1
          
          def get_count(self):
              return self.count
      
      c = Counter()
      c.increment()
      c.increment()
      print(c.get_count())  # 2
      ```
      
      ### Part 3: Protecting State
      
      Validate before changing:
      
      ```python
      class BankAccount:
          def __init__(self, balance=0):
              self.balance = balance
          
          def withdraw(self, amount):
              if amount > self.balance:
                  return False  # Can't withdraw!
              self.balance -= amount
              return True
      ```
    
    instructions: |
      Create a BankAccount class.
      
      Your class should:
      - Initialize with a balance (default 0)
      - Have deposit(amount) method to add money
      - Have withdraw(amount) method to remove money
      - Have get_balance() method to check balance
      - Prevent negative balance on withdraw
    
    starter_code: |
      class BankAccount:
          def __init__(self, balance=0):
              pass
          
          def deposit(self, amount):
              pass
          
          def withdraw(self, amount):
              pass
          
          def get_balance(self):
              pass
    
    hints:
      - "Store balance: self.balance = balance"
      - "deposit: self.balance += amount"
      - "withdraw: check if self.balance >= amount first"
      - "Return False if insufficient funds, True if successful"
    
    tests:
      - class: BankAccount
        operations:
          - method: deposit
            args: [100]
          - method: get_balance
            expected: 100

  - day: 3
    title: "Rectangle Class"
    topic: "Calculated Properties"
    keywords: ["functions", "math"]
    difficulty: intermediate
    time_estimate: "50-65 minutes"
    description: |
      Create a class with calculated properties!
      
      ## ðŸŽ“ LESSON: Calculated Properties
      
      ### Part 1: Storing vs Calculating
      
      Some data is **stored**, some is **calculated**:
      
      ```python
      class Rectangle:
          def __init__(self, width, height):
              self.width = width    # Stored
              self.height = height  # Stored
          
          def area(self):
              return self.width * self.height  # Calculated!
      
      rect = Rectangle(5, 3)
      print(rect.area())  # 15 (calculated from width Ã— height)
      ```
      
      ### Part 2: Why Calculate?
      
      **Benefits:**
      - Always up-to-date
      - No need to update when width/height changes
      - Saves memory
      
      ```python
      rect = Rectangle(5, 3)
      print(rect.area())  # 15
      
      rect.width = 10  # Change width
      print(rect.area())  # 30 (automatically updates!)
      ```
      
      ### Part 3: Real Example
      
      ```python
      class Circle:
          def __init__(self, radius):
              self.radius = radius
          
          def diameter(self):
              return self.radius * 2
          
          def area(self):
              return 3.14159 * self.radius ** 2
      
      c = Circle(5)
      print(c.diameter())  # 10
      print(c.area())      # 78.54
      ```
    
    instructions: |
      Create a Rectangle class.
      
      Your class should:
      - Initialize with width and height
      - Have area() method that returns width * height
      - Have perimeter() method that returns 2 * (width + height)
    
    starter_code: |
      class Rectangle:
          def __init__(self, width, height):
              pass
          
          def area(self):
              pass
          
          def perimeter(self):
              pass
    
    hints:
      - "Store dimensions: self.width = width, self.height = height"
      - "area: return self.width * self.height"
      - "perimeter: return 2 * (self.width + self.height)"
    
    tests:
      - class: Rectangle
        init: [5, 3]
        method: area
        expected: 15

  - day: 4
    title: "Counter Class"
    topic: "State Management"
    keywords: ["functions"]
    difficulty: beginner
    time_estimate: "45-60 minutes"
    description: |
      Create a class that maintains state!
      
      ## ðŸŽ“ LESSON: Building a Counter Class
      
      ### Part 1: Simple State Example
      
      ```python
      class Counter:
          def __init__(self):
              self.count = 0
          
          def increment(self):
              self.count += 1
          
          def get_count(self):
              return self.count
      
      c = Counter()
      c.increment()
      c.increment()
      c.increment()
      print(c.get_count())  # 3
      ```
      
      ### Part 2: Multiple Counters
      
      Each object has its own state:
      
      ```python
      counter1 = Counter()
      counter2 = Counter()
      
      counter1.increment()
      counter1.increment()
      
      counter2.increment()
      
      print(counter1.get_count())  # 2
      print(counter2.get_count())  # 1
      # Different objects, different counts!
      ```
    
    instructions: |
      Create a Counter class.
      
      Your class should:
      - Start at 0
      - Have increment() method to add 1
      - Have decrement() method to subtract 1
      - Have get_count() method to return current count
      - Have reset() method to go back to 0
    
    starter_code: |
      class Counter:
          def __init__(self):
              pass
          
          def increment(self):
              pass
          
          def decrement(self):
              pass
          
          def get_count(self):
              pass
          
          def reset(self):
              pass
    
    hints:
      - "Initialize counter: self.count = 0"
      - "increment: self.count += 1"
      - "decrement: self.count -= 1"
      - "get_count: return self.count"
      - "reset: self.count = 0"
    
    tests:
      - class: Counter
        operations:
          - method: increment
          - method: increment
          - method: get_count
            expected: 2

  - day: 5
    title: "Student Class"
    topic: "Lists in Classes"
    keywords: ["functions", "lists"]
    difficulty: intermediate
    time_estimate: "55-70 minutes"
    description: |
      Manage collections within a class!
      
      ## ðŸŽ“ LESSON: Collections in Classes
      
      ### Part 1: Storing Lists
      
      Classes can store lists as instance variables:
      
      ```python
      class Student:
          def __init__(self, name):
              self.name = name
              self.grades = []  # Empty list
          
          def add_grade(self, grade):
              self.grades.append(grade)
      
      student = Student("Alice")
      student.add_grade(90)
      student.add_grade(85)
      print(student.grades)  # [90, 85]
      ```
      
      ### Part 2: Calculating from Lists
      
      ```python
      class Student:
          def __init__(self, name):
              self.name = name
              self.grades = []
          
          def add_grade(self, grade):
              self.grades.append(grade)
          
          def get_average(self):
              if len(self.grades) == 0:
                  return 0
              return sum(self.grades) / len(self.grades)
      
      alice = Student("Alice")
      alice.add_grade(90)
      alice.add_grade(85)
      alice.add_grade(92)
      print(alice.get_average())  # 89.0
      ```
    
    instructions: |
      Create a Student class.
      
      Your class should:
      - Initialize with name
      - Have an empty grades list
      - Have add_grade(grade) method
      - Have get_average() method that calculates average of all grades
    
    starter_code: |
      class Student:
          def __init__(self, name):
              pass
          
          def add_grade(self, grade):
              pass
          
          def get_average(self):
              pass
    
    hints:
      - "Initialize empty list: self.grades = []"
      - "add_grade: self.grades.append(grade)"
      - "get_average: return sum(self.grades) / len(self.grades)"
      - "Handle case where no grades: return 0 if len == 0"
    
    tests:
      - class: Student
        init: ["Alice"]
        operations:
          - method: add_grade
            args: [90]
          - method: add_grade
            args: [85]
          - method: get_average
            expected: 87.5

  - day: 6
    title: "Shopping Cart"
    topic: "Dictionaries in Classes"
    keywords: ["functions", "dictionaries"]
    difficulty: intermediate
    time_estimate: "60-75 minutes"
    description: |
      Build a shopping cart!
      
      ## ðŸŽ“ LESSON: Dictionaries in Classes
      
      ### Part 1: Using Dicts for Complex State
      
      ```python
      class ShoppingCart:
          def __init__(self):
              self.items = {}  # item -> quantity
          
          def add_item(self, item, qty):
              if item in self.items:
                  self.items[item] += qty
              else:
                  self.items[item] = qty
      
      cart = ShoppingCart()
      cart.add_item("apple", 3)
      cart.add_item("banana", 2)
      cart.add_item("apple", 2)  # Add 2 more
      print(cart.items)  # {"apple": 5, "banana": 2}
      ```
      
      ### Part 2: Dict Methods in Classes
      
      ```python
      def get_total_items(self):
          return sum(self.items.values())
      
      def remove_item(self, item):
          if item in self.items:
              del self.items[item]
      ```
    
    instructions: |
      Create a ShoppingCart class.
      
      Your class should:
      - Have an empty cart (dictionary: item -> quantity)
      - add_item(item, quantity) - adds items
      - remove_item(item) - removes an item completely
      - get_total_items() - returns total quantity of all items
    
    starter_code: |
      class ShoppingCart:
          def __init__(self):
              pass
          
          def add_item(self, item, quantity):
              pass
          
          def remove_item(self, item):
              pass
          
          def get_total_items(self):
              pass
    
    hints:
      - "Initialize cart: self.cart = {}"
      - "add_item: self.cart[item] = self.cart.get(item, 0) + quantity"
      - "remove_item: del self.cart[item] if item in self.cart"
      - "get_total_items: return sum(self.cart.values())"
    
    tests:
      - class: ShoppingCart
        operations:
          - method: add_item
            args: ["apple", 3]
          - method: get_total_items
            expected: 3

  - day: 7
    title: "Week 9 Challenge: Todo List"
    topic: "Complete Class Application"
    keywords: ["functions", "lists", "dictionaries"]
    difficulty: intermediate
    time_estimate: "75-90 minutes"
    description: |
      Build a todo list manager!
      
      ## ðŸŽ“ LESSON: Building Complete Applications with Classes
      
      ### Part 1: Planning the Class
      
      Before coding, think about:
      - What data do we store? (list of todos)
      - What operations do we need? (add, complete, get)
      - What's the structure of each todo? (dict with task + done)
      
      ### Part 2: Data Structure
      
      ```python
      # Each todo is a dictionary
      todo = {
          "task": "Buy milk",
          "done": False
      }
      
      # Store list of todos
      todos = [
          {"task": "Buy milk", "done": False},
          {"task": "Walk dog", "done": True}
      ]
      ```
      
      ### Part 3: Complete TodoList Class
      
      ```python
      class TodoList:
          def __init__(self):
              self.todos = []
          
          def add_task(self, task):
              self.todos.append({
                  "task": task,
                  "done": False
              })
          
          def complete_task(self, index):
              if 0 <= index < len(self.todos):
                  self.todos[index]["done"] = True
          
          def get_pending(self):
              return [t["task"] for t in self.todos if not t["done"]]
          
          def get_completed(self):
              return [t["task"] for t in self.todos if t["done"]]
      
      # Usage
      my_todos = TodoList()
      my_todos.add_task("Buy milk")
      my_todos.add_task("Walk dog")
      my_todos.complete_task(0)
      
      print(my_todos.get_pending())     # ["Walk dog"]
      print(my_todos.get_completed())   # ["Buy milk"]
      ```
    
    instructions: |
      Create a TodoList class.
      
      Your class should:
      - Store todos as a list of dictionaries: {"task": str, "done": bool}
      - add_task(task) - adds new task (not done)
      - complete_task(index) - marks task at index as done
      - get_pending() - returns list of tasks that aren't done
      - get_completed() - returns list of completed tasks
    
    starter_code: |
      class TodoList:
          def __init__(self):
              pass
          
          def add_task(self, task):
              pass
          
          def complete_task(self, index):
              pass
          
          def get_pending(self):
              pass
          
          def get_completed(self):
              pass
    
    hints:
      - "Initialize: self.todos = []"
      - "add_task: self.todos.append({'task': task, 'done': False})"
      - "complete_task: self.todos[index]['done'] = True"
      - "get_pending: [t['task'] for t in self.todos if not t['done']]"
      - "get_completed: [t['task'] for t in self.todos if t['done']]"
    
    tests:
      - class: TodoList
        operations:
          - method: add_task
            args: ["Buy milk"]
          - method: add_task
            args: ["Walk dog"]
          - method: complete_task
            args: [0]
          - method: get_pending
            expected: ["Walk dog"]
