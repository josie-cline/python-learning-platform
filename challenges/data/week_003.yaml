# Week 3: Functions and Data Structures

title: "Functions and Lists"
description: "Master functions and dive deep into Python's most versatile data structure: lists!"
topics:
  - Function parameters and return values
  - Default arguments
  - List operations and methods
  - List slicing
  - List comprehensions (intro)

challenges:
  - day: 1
    title: "Function Basics"
    topic: "Parameters and Return Values"
    keywords: ["functions"]
    difficulty: beginner
    time_estimate: "50-60 minutes"
    description: |
      Deep dive into functions!
      
      ## üéì LESSON: Functions with Parameters
      
      ### Part 1: Review - What Are Functions?
      
      Functions are named blocks of code that you can reuse:
      
      ```python
      def say_hello():
          print("Hello!")
      
      say_hello()  # Call it
      ```
      
      ### Part 2: Parameters (Inputs)
      
      Parameters let you pass data INTO a function:
      
      ```python
      def greet(name):  # 'name' is a parameter
          print(f"Hello, {name}!")
      
      greet("Josie")  # "Josie" is the argument
      greet("Alice")  # "Alice" is the argument
      ```
      
      **Terminology:**
      - **Parameter** - The variable in the function definition (`name`)
      - **Argument** - The actual value you pass in (`"Josie"`)
      
      ### Part 3: Multiple Parameters
      
      Functions can take multiple parameters:
      
      ```python
      def add(a, b):  # Two parameters
          return a + b
      
      result = add(5, 3)  # Two arguments: 5 and 3
      # result is 8
      ```
      
      **Order matters!**
      ```python
      def introduce(name, age):
          print(f"{name} is {age} years old")
      
      introduce("Josie", 25)  # Correct
      introduce(25, "Josie")  # Wrong order!
      ```
      
      ### Part 4: Return Values (Outputs)
      
      `return` gives back a value to whoever called the function:
      
      ```python
      def double(x):
          return x * 2
      
      result = double(5)  # result is 10
      print(result)       # Prints: 10
      ```
      
      **Without return:**
      ```python
      def double(x):
          x * 2  # Calculates but doesn't return!
      
      result = double(5)  # result is None
      ```
      
      ### Part 5: Return vs Print
      
      **These are different!**
      
      ```python
      def add_print(a, b):
          print(a + b)  # Shows on screen
      
      def add_return(a, b):
          return a + b  # Gives back a value
      
      x = add_print(5, 3)   # Prints 8, x is None
      y = add_return(5, 3)  # y is 8
      ```
      
      **When to use each:**
      - `print()` - Show information to the user
      - `return` - Give a value back to use in code
      
      ### Part 6: Using Returned Values
      
      You can use returned values in more calculations:
      
      ```python
      def square(x):
          return x * x
      
      a = square(3)      # 9
      b = square(4)      # 16
      total = a + b      # 25
      
      # Or all at once:
      total = square(3) + square(4)  # 25
      ```
    
    instructions: |
      Create a function `calculate_area(length, width)` that calculates
      the area of a rectangle and returns it.
      
      **Formula:** Area = length √ó width
      
      **Step-by-step:**
      1. Multiply length by width
      2. Return the result
      
      **Solution:**
      ```python
      def calculate_area(length, width):
          area = length * width
          return area
      ```
      
      **Or shorter:**
      ```python
      def calculate_area(length, width):
          return length * width
      ```
      
      **Test it:**
      ```python
      calculate_area(5, 3)   # 15
      calculate_area(10, 2)  # 20
      calculate_area(4, 4)   # 16
      ```
    
    starter_code: |
      def calculate_area(length, width):
          # Multiply length by width
          # Return the result
          pass
    
    hints:
      - "Area = length * width"
      - "Use the return keyword"
      - "return length * width"
    
    tests:
      - function: calculate_area
        input: [5, 3]
        expected: 15
      
      - function: calculate_area
        input: [10, 2]
        expected: 20

  - day: 2
    title: "Default Arguments"
    topic: "Optional Parameters"
    keywords: ["functions"]
    difficulty: beginner
    time_estimate: "30-40 minutes"
    description: |
      Learn how to set default values for function parameters!
      
      ## üéì LESSON: Default Arguments
      
      ### Part 1: What Are Default Arguments?
      
      Sometimes you want a parameter to be **optional**. Default arguments let callers skip parameters.
      
      **Without defaults:**
      ```python
      def greet(name, greeting):
          return f"{greeting}, {name}!"
      
      greet("Alice", "Hello")  # Must provide both
      greet("Bob")  # ERROR! Missing greeting
      ```
      
      **With defaults:**
      ```python
      def greet(name, greeting="Hello"):
          return f"{greeting}, {name}!"
      
      greet("Alice", "Hello")  # Hello, Alice!
      greet("Bob")            # Hello, Bob! (uses default)
      greet("Charlie", "Hi")  # Hi, Charlie!
      ```
      
      ### Part 2: Syntax
      
      Set default by using `=` in parameter list:
      
      ```python
      def function_name(required_param, optional_param="default value"):
          # Function body
      ```
      
      **Rules:**
      - Parameters with defaults come **after** required ones
      - Can have multiple default parameters
      
      ### Part 3: Examples
      
      **Example 1: Welcome message**
      ```python
      def welcome(name, title="Guest"):
          return f"Welcome, {title} {name}!"
      
      print(welcome("Alice"))           # Welcome, Guest Alice!
      print(welcome("Bob", "Dr."))      # Welcome, Dr. Bob!
      ```
      
      **Example 2: Multiple defaults**
      ```python
      def create_user(username, role="user", active=True):
          return {
              "username": username,
              "role": role,
              "active": active
          }
      
      create_user("alice")                    # Uses both defaults
      create_user("bob", "admin")             # Overrides role
      create_user("charlie", "user", False)   # Overrides both
      ```
      
      ### Part 4: Common Mistakes
      
      ‚ùå **Required after optional:**
      ```python
      def bad(optional="default", required):  # SyntaxError!
          pass
      ```
      
      ‚úÖ **Required before optional:**
      ```python
      def good(required, optional="default"):
          pass
      ```
    
    instructions: |
      Create a function `greet(name, greeting="Hello")` that greets someone.
      If no greeting is provided, use "Hello" as default.
      
      Return: "{greeting}, {name}!"
    
    starter_code: |
      def greet(name, greeting="Hello"):
          # Return the greeting message
          pass
    
    hints:
      - "Use f-strings or concatenation"
      - "f'{greeting}, {name}!'"
      - "Default arguments come after required ones"
    
    tests:
      - function: greet
        input: ["Alice"]
        expected: "Hello, Alice!"
      
      - function: greet
        input: ["Bob", "Hi"]
        expected: "Hi, Bob!"

  - day: 3
    title: "List Operations"
    topic: "Adding and Removing Items"
    keywords: ["lists", "functions"]
    difficulty: beginner
    time_estimate: "40-50 minutes"
    description: |
      Lists are Python's most versatile data structure. Learn to manipulate them!
      
      ## üéì LESSON: List Methods
      
      ### Part 1: Lists Are Mutable
      
      Unlike strings, lists can be **changed** after creation:
      
      ```python
      numbers = [1, 2, 3]
      numbers.append(4)  # Changes the list!
      print(numbers)     # [1, 2, 3, 4]
      ```
      
      ### Part 2: Adding Items - append()
      
      `.append()` adds one item to the **end**:
      
      ```python
      fruits = ["apple", "banana"]
      fruits.append("cherry")
      print(fruits)  # ["apple", "banana", "cherry"]
      ```
      
      ### Part 3: Adding Items - insert()
      
      `.insert()` adds at a **specific position**:
      
      ```python
      colors = ["red", "blue"]
      colors.insert(1, "green")  # Insert at index 1
      print(colors)  # ["red", "green", "blue"]
      ```
      
      ### Part 4: Removing Items - remove()
      
      `.remove()` deletes the first occurrence of a value:
      
      ```python
      numbers = [1, 2, 3, 2]
      numbers.remove(2)  # Removes first 2
      print(numbers)     # [1, 3, 2]
      ```
      
      ### Part 5: Removing Items - pop()
      
      `.pop()` removes and **returns** the last item:
      
      ```python
      stack = [1, 2, 3]
      last = stack.pop()  # Returns 3
      print(last)         # 3
      print(stack)        # [1, 2]
      ```
      
      `.pop(index)` can remove from any position:
      
      ```python
      items = ["a", "b", "c"]
      items.pop(1)  # Remove index 1
      print(items)  # ["a", "c"]
      ```
      
      ### Part 6: Common Methods Summary
      
      ```python
      my_list = [1, 2, 3]
      
      my_list.append(4)      # Add to end: [1, 2, 3, 4]
      my_list.insert(0, 0)   # Add at index: [0, 1, 2, 3, 4]
      my_list.remove(2)      # Remove value: [0, 1, 3, 4]
      my_list.pop()          # Remove last: [0, 1, 3]
      my_list.clear()        # Remove all: []
      ```
    
    instructions: |
      Create a function `add_to_list(my_list, item)` that adds an item to
      the end of a list and returns the modified list.
    
    starter_code: |
      def add_to_list(my_list, item):
          # Add item to list and return it
          pass
    
    hints:
      - "Use the append() method"
      - "my_list.append(item)"
      - "Don't forget to return the list"
    
    tests:
      - function: add_to_list
        input: [[1, 2, 3], 4]
        expected: [1, 2, 3, 4]

  - day: 4
    title: "List Slicing"
    topic: "Accessing Parts of Lists"
    keywords: ["lists"]
    difficulty: intermediate
    time_estimate: "40-50 minutes"
    description: |
      Slicing lets you get subsets of lists. It's powerful and elegant!
      
      ## üéì LESSON: List Slicing
      
      ### Part 1: What is Slicing?
      
      Slicing extracts a portion of a list:
      
      ```python
      numbers = [0, 1, 2, 3, 4, 5]
      subset = numbers[1:4]  # [1, 2, 3]
      ```
      
      ### Part 2: Slicing Syntax
      
      **Format:** `list[start:end:step]`
      
      - `start` - Where to begin (inclusive)
      - `end` - Where to stop (exclusive!)
      - `step` - How many to skip (optional, default 1)
      
      ```python
      numbers = [0, 1, 2, 3, 4, 5]
      
      numbers[1:4]    # [1, 2, 3] - from index 1 to 3
      numbers[:3]     # [0, 1, 2] - from start to index 2
      numbers[3:]     # [3, 4, 5] - from index 3 to end
      numbers[::2]    # [0, 2, 4] - every 2nd item
      numbers[::-1]   # [5, 4, 3, 2, 1, 0] - reverse!
      ```
      
      ### Part 3: Key Points
      
      **End is exclusive:**
      ```python
      nums = [0, 1, 2, 3, 4]
      nums[1:3]  # [1, 2] - stops BEFORE index 3
      ```
      
      **Negative indices:**
      ```python
      nums = [0, 1, 2, 3, 4]
      nums[-2:]   # [3, 4] - last 2 items
      nums[:-2]   # [0, 1, 2] - all except last 2
      ```
      
      ### Part 4: Common Patterns
      
      ```python
      data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
      
      # First 3
      data[:3]      # [1, 2, 3]
      
      # Last 3
      data[-3:]     # [8, 9, 10]
      
      # Middle (skip first and last)
      data[1:-1]    # [2, 3, 4, 5, 6, 7, 8, 9]
      
      # Every other
      data[::2]     # [1, 3, 5, 7, 9]
      
      # Reverse
      data[::-1]    # [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
      ```
    
    instructions: |
      Create a function `get_first_three(my_list)` that returns the first
      three elements of a list.
    
    starter_code: |
      def get_first_three(my_list):
          # Return first three elements
          pass
    
    hints:
      - "Use list slicing: my_list[start:end]"
      - "my_list[0:3] or my_list[:3]"
      - "Start at 0, end before 3"
    
    tests:
      - function: get_first_three
        input: [[1, 2, 3, 4, 5]]
        expected: [1, 2, 3]

  - day: 5
    title: "List Reverse"
    topic: "Reversing and Sorting"
    keywords: ["lists", "functions"]
    difficulty: beginner
    time_estimate: "30-40 minutes"
    description: |
      Learn to reverse and sort lists!
      
      ## üéì LESSON: Reversing and Sorting
      
      ### Part 1: Reversing Lists
      
      **Method 1: Slicing (creates new list)**
      ```python
      numbers = [1, 2, 3, 4, 5]
      reversed_nums = numbers[::-1]
      
      print(reversed_nums)  # [5, 4, 3, 2, 1]
      print(numbers)        # [1, 2, 3, 4, 5] - original unchanged
      ```
      
      **Method 2: reverse() method (modifies in-place)**
      ```python
      numbers = [1, 2, 3, 4, 5]
      numbers.reverse()
      
      print(numbers)  # [5, 4, 3, 2, 1] - original changed!
      ```
      
      **Method 3: reversed() function**
      ```python
      numbers = [1, 2, 3, 4, 5]
      reversed_nums = list(reversed(numbers))
      
      print(reversed_nums)  # [5, 4, 3, 2, 1]
      ```
      
      ### Part 2: Sorting Lists
      
      **Method 1: sorted() function (creates new list)**
      ```python
      numbers = [3, 1, 4, 1, 5]
      sorted_nums = sorted(numbers)
      
      print(sorted_nums)  # [1, 1, 3, 4, 5]
      print(numbers)      # [3, 1, 4, 1, 5] - original unchanged
      ```
      
      **Method 2: sort() method (modifies in-place)**
      ```python
      numbers = [3, 1, 4, 1, 5]
      numbers.sort()
      
      print(numbers)  # [1, 1, 3, 4, 5] - original changed!
      ```
      
      **Reverse sort:**
      ```python
      numbers = [3, 1, 4, 1, 5]
      sorted_nums = sorted(numbers, reverse=True)
      print(sorted_nums)  # [5, 4, 3, 1, 1]
      ```
      
      ### Part 3: In-Place vs New List
      
      | Operation | Creates new? | Changes original? |
      |-----------|--------------|-------------------|
      | `list[::-1]` | ‚úÖ Yes | ‚ùå No |
      | `list.reverse()` | ‚ùå No | ‚úÖ Yes |
      | `sorted(list)` | ‚úÖ Yes | ‚ùå No |
      | `list.sort()` | ‚ùå No | ‚úÖ Yes |
    
    instructions: |
      Create a function `reverse_list(my_list)` that returns a reversed
      copy of the list.
    
    starter_code: |
      def reverse_list(my_list):
          # Return reversed list
          pass
    
    hints:
      - "Use list slicing: my_list[::-1]"
      - "Or use the reversed() function"
      - "return list(reversed(my_list))"
    
    tests:
      - function: reverse_list
        input: [[1, 2, 3, 4]]
        expected: [4, 3, 2, 1]

  - day: 6
    title: "Remove Duplicates"
    topic: "List Processing"
    keywords: ["lists", "loops"]
    difficulty: intermediate
    time_estimate: "45-60 minutes"
    description: |
      Remove duplicate values from a list!
      
      ## üéì LESSON: Removing Duplicates
      
      ### Part 1: The Problem
      
      Lists can have duplicate values:
      
      ```python
      numbers = [1, 2, 2, 3, 1, 4, 3]
      # We want: [1, 2, 3, 4]
      ```
      
      How do we remove duplicates?
      
      ### Part 2: Method 1 - Using a Set
      
      Sets automatically remove duplicates:
      
      ```python
      numbers = [1, 2, 2, 3, 1, 4]
      unique = list(set(numbers))
      print(unique)  # [1, 2, 3, 4]
      ```
      
      **Problem:** Loses original order!
      
      ### Part 3: Method 2 - Loop and Track Seen Items
      
      Keep order by tracking what we've seen:
      
      ```python
      def remove_duplicates(numbers):
          seen = []
          result = []
          
          for num in numbers:
              if num not in seen:
                  seen.append(num)
                  result.append(num)
          
          return result
      
      numbers = [1, 2, 2, 3, 1, 4]
      print(remove_duplicates(numbers))  # [1, 2, 3, 4] - order kept!
      ```
      
      ### Part 4: Method 3 - Using a Set for Tracking
      
      More efficient - sets have O(1) lookup:
      
      ```python
      def remove_duplicates(numbers):
          seen = set()
          result = []
          
          for num in numbers:
              if num not in seen:
                  seen.add(num)
                  result.append(num)
          
          return result
      ```
      
      **Why better?**
      - `num in set` is faster than `num in list`
      - Keeps order unlike `list(set(numbers))`
    
    instructions: |
      Create a function `remove_duplicates(my_list)` that returns a new list
      with duplicates removed (keep original order).
    
    starter_code: |
      def remove_duplicates(my_list):
          # Remove duplicates and return new list
          pass
    
    hints:
      - "Keep track of seen items"
      - "Loop through and only add if not seen before"
      - "Or convert to set and back: list(set(my_list))"
    
    tests:
      - function: remove_duplicates
        input: [[1, 2, 2, 3, 1, 4]]
        expected: [1, 2, 3, 4]

  - day: 7
    title: "Week 3 Challenge: List Statistics"
    topic: "Combining Everything"
    keywords: ["lists", "functions", "loops", "math"]
    difficulty: intermediate
    time_estimate: "60 minutes"
    description: |
      Create a function that calculates statistics for a list of numbers!
      
      ## üéì LESSON: List Statistics
      
      ### Part 1: Statistical Functions
      
      Common statistics you might calculate:
      
      - **Minimum** - Smallest value
      - **Maximum** - Largest value  
      - **Average** - Sum divided by count
      - **Sum** - Total of all values
      
      ### Part 2: Built-in Functions
      
      Python has functions for these:
      
      ```python
      numbers = [1, 5, 3, 9, 2]
      
      min(numbers)     # 1 - smallest
      max(numbers)     # 9 - largest
      sum(numbers)     # 20 - total
      len(numbers)     # 5 - count
      
      # Average = sum / count
      avg = sum(numbers) / len(numbers)  # 4.0
      ```
      
      ### Part 3: Returning Multiple Values
      
      Use a dictionary to return multiple statistics:
      
      ```python
      def get_stats(numbers):
          return {
              "min": min(numbers),
              "max": max(numbers),
              "average": sum(numbers) / len(numbers)
          }
      
      stats = get_stats([1, 2, 3, 4, 5])
      print(stats)
      # {"min": 1, "max": 5, "average": 3.0}
      ```
      
      ### Part 4: Rounding
      
      Average might have many decimals:
      
      ```python
      numbers = [1, 2, 3]
      avg = sum(numbers) / len(numbers)  # 2.0
      
      numbers = [1, 2, 4]
      avg = sum(numbers) / len(numbers)  # 2.3333333...
      
      # Round to 2 decimals
      avg_rounded = round(avg, 2)  # 2.33
      ```
      
      ### Part 5: Complete Example
      
      ```python
      def calculate_stats(numbers):
          stats = {
              "min": min(numbers),
              "max": max(numbers),
              "average": round(sum(numbers) / len(numbers), 2)
          }
          return stats
      
      result = calculate_stats([10, 20, 30, 40, 50])
      print(result)
      # {"min": 10, "max": 50, "average": 30.0}
      ```
    
    instructions: |
      Create a function `calculate_stats(numbers)` that returns a dictionary with:
      - "min": minimum value
      - "max": maximum value
      - "average": average value (rounded to 2 decimals)
      
      Example:
      calculate_stats([1, 2, 3, 4, 5]) returns {"min": 1, "max": 5, "average": 3.0}
    
    starter_code: |
      def calculate_stats(numbers):
          # Calculate and return statistics
          pass
    
    hints:
      - "Use min(), max(), and sum() functions"
      - "Average = sum / length"
      - "round(value, 2) rounds to 2 decimals"
    
    tests:
      - function: calculate_stats
        input: [[1, 2, 3, 4, 5]]
        expected: {"min": 1, "max": 5, "average": 3.0}
